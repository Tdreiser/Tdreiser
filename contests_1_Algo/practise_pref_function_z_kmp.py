def z_funct(s):
    '''
    Z - функция
    Тривиальный алгоритм. Функция бежит по всем индексам строки
    и сравнивает посимвольно преффикс строки и преффикс начиная с каждого
    символа кроме нулевого
    '''
    n=len(s)
    z=[0]*n
    for i in range(1, n):
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
            
           
    return z
    


def z_funct_new(s):
    '''
    Почти тоже самое только цикл while не включается что бы промотать
    каждый элемент т.к есть r и l границы которые контролируют цикл
    '''
    n=len(s)
    z=[0]*n
    l=0
    r=0
    for i in range(1, n):

        if i <= r:
            z[i]=min(r-i+1,z[i-l])
            
        else:
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
                
        if i+z[i]-1 > r:
            l=i
            r=i+z[i]-1
           
        
    return z

   

def search_sub(a,sub):
    '''
    Поиск подстроки в строке. Тривиальный. Посимвольно применяет шаблон
    к строке если равен выводит на экран индекс места где это произошло
    '''
    for i in range(0,len(a)-len(sub)+1):
        if sub == a[i:i+len(sub)]:
            print(i)
            
def search_sub_new(a,sub):
    '''
    Тот же поиск подстроки только с Z- функцией. В начале в качестве префикса
    вставляем подстроку через разделитель # и в месте где длинна подстроки
    будет равна z функции выведет его на экран
    '''
    ns=sub+'#'+a
    z=z_funct_new(ns)

    for i in range(len(a)-1):
        if z[i+len(sub)+1] == len(sub):
            print(i)
  
#search_sub_new(ss,'aaa')

def subs_count(s):
    '''
    Здесь сразу применим z- функцию. Инвертируем  нашу строку и перебираем префиксы
    добавляя по одному символу. Текущее кол-во различных подстрок = длиннa строки - Z функция
    от этой строки.
    '''
    t=''
    sp = [c for c in s]
    sp.reverse()
    s=''
    for c in sp:
        s+=c
    m=0
    for c in s:
        t=c+t
        m+=len(t)-max(z_funct_new(t))
    return m

def period_of_string(s):
    '''
    Для данной строки s находим строку x минимальной длины,
    такую что s можно предстваить как конкатенацию одной или нескольких копий x
    реверсим z функцию и примеряем по длинне что подходит к строке умноженной на z функцию.
    '''
    z=z_funct_new(s)
    for x in reversed(z):
        if x!=0 and (len(s)//x)*s[-x:] == s:
            
            return s[-x:]
    else:
        return s
    




def prefix_func(s):
    '''
    ПИ функция сравнивает префикс с  собственным суффиксом
    '''
    n=len(s)
    pi = [0] * n #инициализируем массив равный длинны строки
    for i in range(n): #возьмем отрезок  начало
        for k in range(1, i + 1): # это конец отрезка
            equal = True
            for j in range(k): #по элементно сравниваем
                if s[j] != s[i - k  + 1 + j]: #если  элемент суффикса не равен элементу префикса
                    equal = False # выйдем из цикла и увеличим конец отрезка на 1( префикс +1)
                    break
            if equal:  #в конце у нас на каждой итерации преффикс функция либо равна 0
                pi[i] = k # либо равна длинне префикса ( ну нельзя же срезами просто шагать?!!!
            
    return pi




def prefix_func_new(s):
    '''
    Вот и сам КМП.O(n)
    '''
    n=len(s)
    pi=[0]*n #инициализируем список pi функции
    j=0 
    i=1
    while i<n: #пока шаблон не закончился
        if s[i]==s[j]:# сравниваем префикс и суффикс
            pi[i]=j+1 #т.к они равны то pi функция равна j+1
            j+=1 #шагаем дальше
            i+=1 #вторую границу тоже смещаем
        else:
            if j==0: #в начале j=0
                pi[i]=0
                i+=1
            else: # если нет то j должно отойти назад, так мы будем отталкиваться от уже известных значений Pi
                j=pi[j-1]
        
    return pi
      
def kmp_sub_search(s,sub):
    '''
    Поиск подстрок с помощью алгоритма Кнута -Морриса-Пратта O(n+m)
    Оптимизирован для пересекающихся строк
    Вернет список вхождений подстроки в строку.
    '''
    l=0#индекс подстроки
    k=0#индекс строки
    pi=prefix_func_new(sub)# формируем образ
    indexes=[]
    m=len(s)# посчитаем длинну строки один раз]
    n=len(sub)# то же самое и для подстроки
    while k<m:# пока индекс k не дошел до конца строки проверяем условие
        if s[k]==sub[l]: #если совпали то шагнём к следующим символам
            k+=1 
            l+=1
            if l==n:# а если еще и индекс подстроки равен её длинне
                indexes.append(k-n) # то в результирующий список закинем индекс где это совпадение нашли
                k-=pi[l-1] # на случай если вдруг они пересекаются то отматаем столько сколько индексов он уже пересек
                l=0 # Ищем теперь с начала
               
        elif s[k]!=sub[l] and l==0: # если символы не равны, но индекс подстроки равен 0
            k+=1# то уменьшать индекс подстроки уже некуда  и мы будем искать со след символа строки
        else:
            l=pi[l-1] # иначе отмотаем индекс подстроки от уже известных значений pi функции
        
    return indexes
             
def kmp_subs_counts(s):
    '''
    кмп алгоритм для счёта всех различных подсстрок. вся хитрость в том что нужно
    прибавлять к новой строке t символы из строки в обратном порядке и тогда мы
    будем вычислять кол-во новых подстрок  так же как и для z функции
    '''
    t=''
    sp = [c for c in s]
    sp.reverse()
    s=''
    for c in sp:
        s+=c
    z=0
    for c in s:
        t=c+t
        z+=len(t)-max(prefix_func_new(t))
        
    return z

def kmp_period_of_string(s):
    '''
    Для данной строки s находим строку x минимальной длины,
    такую что s можно предстваить как конкатенацию одной или нескольких копий x
    считаем pi функцию и примеряем по длинне что подходит к строке умноженной на pi функцию.
    '''
    z=prefix_func_new(s)
    for x in z:
        if x!=0 and (len(s)//x)*s[-x:] == s:  
            return s[-x:] 
    else:
        return

def tst():
    
    s='ababa'
    n=len(s)
    b=[0]*n
    for i in range(2,len(s)):
        z=1
        while z<len(s[:i]):
            if s[:z] in s[:i+1][1:-1] :
                z+=1
            else:
                break
                
        b[i]=z-1
    return(b)

ss='ababa'
print(prefix_func_new(ss))    
#print(tst())        
