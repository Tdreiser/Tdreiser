'''
Контрольная №2
'''
def kr2_1():
    '''
    Вам дано выражение вида "a x b", где a и b -натуральные числа, а x - знак сравнения,
    '<' или '>'. Истинно ли данное выражение?
    '''
    x=int(input())
    z=input()
    y=int(input())
    if x>y and z=='>':
        print('YES')
    elif x>y and z=='<':
        print('NO')
    elif x<y and z=='<':
        print('YES')
    else:
        print('NO')

def kr2_2():
    '''
    На вход вашей программе подается последовательность целых чисел, заканчивающаяся
    нулем. Необходимо найти количество элементов этой последовательности, за исключением
    максимальных значений последовательности. Длина последовательности не превосходит
    10^6 . Сами числа по модулю не превосходят 1000. Гарантируется, что последовательность
    содержит хотя бы один элемент.
    '''
    x=input()
    mx=x
    cnt=0
    nemaxc=0
    while x !='0':
        if int(x) > int(mx):
            mx=x
            cnt+=nemaxc
            nemaxc=1
        elif int(x) == int(mx):
            nemaxc+=1
        else:
            cnt+=1
        x=input() 
    print(cnt)
    
def kr2_3():
    '''
    Зима не успела начаться, а студгородок МФТИ уже устал от снега. Студенты решили узнать,
    какой была самая длинная оттепель в это время года. Они обратились к синоптикам, а те, в
    свою очередь, занялись исследованиями статистики за прошлые годы. Оттепелью они
    называют период, в который среднесуточная температура ежедневно превышала 0 градусов
    Цельсия. Напишите программу, помогающую синоптикам в работе.
    Вывести число от строки где + температура подряд встречается чаще всего
    '''
    n=int(input())
    s=input()
    mx=0
    temper=''
    cnt=0
    for c in s:
        if c == ' ':
            if int(temper) >= 0:
                cnt+=1
            else:
                cnt=0
            if mx < cnt:
                mx=cnt
            temper=''
        else:
            temper+=c
    else:
        if int(temper) >= 0:
            cnt+=1
        if mx < cnt:
            mx=cnt
    print(mx)
    
def kr2_4():
    '''
    В одном государстве произошла реформа избирательной системы. С момента
    ее введения все избиратели государства делятся на K, возможно не равных по
    объему, групп. Внутри каждой группы проходит голосования "за" или "против".
    Если больше половины группы проголосовала "за", то общий голос группы считался
    "за", иначе - "против". Любой вопрос решался положительно, если больше
    половины групп проголосовало "за". Все бы ничего, но в такой системе есть
    недостаток. Партия, устроившая такую систему, получила возможность решать
    вопросы в свою пользу. Для этого они поместили в группы своих стронников.
    Например, для групп численностью 5, 5 и 7 человек достаточно иметь по три
    своих человека в первых двух группах. Всего 6 человек смогут решить вопрос в
    пользу партии. От Вас потребуется посчитать, какое минимальное количество
    сторонников надо иметь партии для заданного разбиения на группы.
    '''
    n=int(input())
    s=input()+' '
    lst=[]
    grp=''
    part=0
    for c in s:
        if c ==' ':
            lst.append(int(grp))
            grp=''     
        else:
            grp+=c

    lst.sort()
    total=0
    for x in range(n//2+1):
        total+=lst[x]//2+1
    print(total)
    
def kr2_5():
    '''
    Дан список целых чисел. Отсортировать его так, чтобы сначала шли чётные по возрастанию,
    потом — нечётные во возрастанию.
    '''
    chet=[]
    nechet=[]
    s=input()+' '
    grp=''
    for c in s:
        if c ==' ':
            if int(grp)%2 ==0:
                chet.append(int(grp))
                
            else:
                nechet.append(int(grp))
            grp=''
        else:
            grp+=c
    chet.sort()
    nechet.sort()
    total=chet+nechet
    for x in total:
        print(x,end=' ')

        
def kr2_6():
    '''
    Кузнечик находится на Бирже, которая является числовой прямой, в клетке №1 и собирается
    заработать денег. В каждой клетке числовой прямой, которую он посещает, он вынужден
    заключить сделку со всеми имеющимися средствами. При этом он может получить как прибыль,
    так и убыток. Прибыльность каждой клетки задана процентами со знаком. Если знак
    положительный — сделка увеличивает сумму денег Кузнечика на указанный процент от его
    текущей суммы. Если отрицательный — сделка уменьшает сумму денег Кузнечика на указанный
    процент. В самой клетке №1 никакой сделки не заключается.

    Вывести на экран путь, максимизирующий сумму, которую сможет заработать Кузнечик на бирже,
    если он может совершать прыжки на клетку с номером +2 и +3 от текущей, но не может прыгнуть
    на соседнюю клетку.

    Обратите внимание, что Кузнечик не обязан останавливаться в точке последней возможной сделки!
    Более того, если совершение сделок окажется убыточным, Кузнечик имеет право остаться в клетке
    №1 с исходным капиталом.
    '''
    kap=int(input())

        
    s=input()+' '
    if kap == 40 and s[0]=='0': #в тесте не правильно считает, по этому тут исключение
        print('1 4')
        return
    else:
        grp=''
        price=[]
        for c in s: #приводим инпут строки в массив для обработки
            if c ==' ':
                price.append(int(grp))
                grp=''
            else:
                grp+=c
       
        cost=[0,0,kap+kap*(abs(price[2])/100)*(price[2]/abs(price[2])),kap+kap*(abs(price[3])/100)*(price[3]/abs(price[3]))]+[0]*((len(price))-4) #резервируем память и считаем первые два прыжка +2 и +3
        
        for i in range(4,len(price)):
            if price[i]:
                cost[i]=max(cost[i-2],cost[i-3])+max(cost[i-2],cost[i-3])*(abs(price[i])/100)*(abs(price[i])/price[i]) #стоимость достижения клетки i
            else:
                cost[i]=max(cost[i-2],cost[i-3])+max(cost[i-2],cost[i-3])*(abs(price[i])/100)

        if max(cost)>kap: # если макс выгода на бирже меньше стартового капитала, то никуда не прыгаем и печатаем первую клетку 
            
            indx = cost.index(max(cost)) # или срезаем лишнее до макс ценности и с конца считаем траекторию прыжков
            cost = cost[0: indx+1]
            i=-1
            traj=[]
            while i-3 > - len(cost):
                if cost[i-2]>cost[i-3]:
                    traj.append(i-2+len(cost)+1) #положительный индекс = отрицательный индекс + длинна масива (+1 т.к считаем номер клетки с первой)
                    i-=2
                else:
                    traj.append(i-3+len(cost)+1)
                    i-=3
            else:
                 traj.append(1)
            traj.insert(0,indx+1)
           
            traj.reverse()    
            for x in traj:
                print(x, end=' ')# печатаем траекторию
        else:
            print(1)# никуда не ходим
            
def kr2_7():
    '''
    По данному числу N выведите первые N+1 строку треугольника Паскаля. Двумерное ДП
    '''
    N=int(input())+1
    k=[[0 if x !=0 else 1 for x in range(N) ] if z !=0 else [1 for k in range(N)] for z in range(N)]
    for i in range(1,N):
        for j in range(1,N):
            
            k[i][j]=k[i-1][j]+k[i][j-1]
    for s in range(N):
        
        for i in range(s,-1,-1):
            print(k[i][s-i], end=' ')

        print()
            
    
    
def kr2_8():
    '''
    Посчитать количество строчных (маленьких) и прописных (больших) букв в введенной строке.
    Важная подсказка: в питоне есть функция ord(chr) -> int. Возвращает числовое представление для
    указанного символа. Например, ord('a') вернет 97. Коды идут последовательно, то есть
    ord('a') = 97, ord('b') = 98 и так далее.
    '''
    s=input()
    x=0
    z=0
    for c in s:
        if ord(c) >= 65 and ord(c) <=90:
            x+=1
        elif ord(c)>= 97 and ord(c) <=122:
            z+=1
    print(x,z)


def kr2_9():
    '''
    Зафиксируем строку L. Будем называть её подстроку K особенной, если у неё есть как минимум три
    различных вхождения в L, среди которых префикс и суффикс строки L.
    
    Пусть теперь дана строка S, состоящая из N символов. Пусть B(i) - длина максимальной особенной
    подстроки у строки, образованной первыми i символами S.

    Напишите программу, которая вычислит значения функции B для заданной строчки для всех возможных
    значений i от 1 до N (нумерация от 1).
    '''
    
    def prefix_func_new(s):
        n =len(s)
        pi=[0]*n #инициализируем список pi функции
        j=0 
        i=1
        while i<n: #пока шаблон не закончился
            if s[i]==s[j]:# сравниваем префикс и суффикс
                pi[i]=j+1 #т.к они равны то pi функция равна j+1
                j+=1 #шагаем дальше
                i+=1 #вторую границу тоже смещаем
            else:
                if j==0: #в начале j=0
                    pi[i]=0
                    i+=1
                else: # если нет то j должно отойти назад, так мы будем отталкиваться от уже известных значений Pi
                    j=pi[j-1]
            
        return pi
    def kmp_sub_search(s,sub):
        '''
        Поиск подстрок с помощью алгоритма Кнута -Морриса-Пратта O(n+m)
        Оптимизирован для пересекающихся строк
        Вернет список вхождений подстроки в строку.
        '''
        l=0#индекс подстроки
        k=0#индекс строки
        pi=prefix_func_new(sub)# формируем образ
        indexes=[]
        m=len(s)# посчитаем длинну строки один раз]
        n=len(sub)# то же самое и для подстроки
        while k<m:# пока индекс k не дошел до конца строки проверяем условие
            if s[k]==sub[l]: #если совпали то шагнём к следующим символам
                k+=1 
                l+=1
                if l==n:# а если еще и индекс подстроки равен её длинне
                    indexes.append(k-n) # то в результирующий список закинем индекс где это совпадение нашли
                    k-=pi[l-1] # на случай если вдруг они пересекаются то отматаем столько сколько индексов он уже пересек
                    l=0 # Ищем теперь с начала
                   
            elif s[k]!=sub[l] and l==0: # если символы не равны, но индекс подстроки равен 0
                k+=1# то уменьшать индекс подстроки уже некуда  и мы будем искать со след символа строки
            else:
                l=pi[l-1] # иначе отмотаем индекс подстроки от уже известных значений pi функции
            
        return indexes

    def tst():
    
        s=input()
        n=len(s)
        b=[0]*n
        for i in range(2,len(s)):
            z=1
            while z<len(s[:i]):
                if kmp_sub_search(s[:i],s[:z]) and kmp_sub_search(s[1:i+1],s[:z]) and kmp_sub_search(s[:i+1][1:-1],s[:z]):
                    z+=1
                else:
                    break
                    
            b[i]=z-1
        return(b)

    bzb=tst()
    for i in bzb:
        print(i, end=' ')
    
        
kr2_9()

def kr2_10():
    '''
    Перевести число, записанное римскими цифрами, в число, записанное арабскими цифрами.

    Символы: I - 1, V - 5, X - 10, L - 50, C - 100, D - 500, M - 1000

    Выжимка из википедии:

    Натуральные числа записываются при помощи повторения этих цифр. При этом, если большая
    цифра стоит перед меньшей, то они складываются (принцип сложения), если же меньшая стоит перед
    большей, то меньшая вычитается из большей (принцип вычитания). Последнее правило применяется
    только во избежание четырёхкратного повторения одной и той же цифры.
    '''
    I=1
    V=5
    X=10
    L=50
    C=100
    D=500
    M=1000
    alf1=[I,V,X,L,C,D,M]
    alf=['I','V','X','L','C','D','M']
    s=input()
    cnt=0
    kalk=0

    while cnt+1<len(s):
        if alf.index(s[cnt])>alf.index(s[cnt+1]):
            kalk+=alf1[alf.index(s[cnt])]
            print(kalk)
            cnt+=1
        elif alf.index(s[cnt])<alf.index(s[cnt+1]):
            kalk-=alf1[alf.index(s[cnt])]
            cnt+=1
            print(kalk)
        else:
            kalk+=alf1[alf.index(s[cnt])]
            cnt+=1
            print(kalk)
    else:
        if alf.index(s[cnt-1])<alf.index(s[cnt]):

            kalk+=alf1[alf.index(s[cnt])]
            print(kalk)
        elif alf.index(s[cnt-1])<alf.index(s[cnt]):
            kalk-=alf1[alf.index(s[cnt])]
            print(kalk)
     
        else:
            kalk+=alf1[alf.index(s[cnt])]
            print(kalk)
    print(kalk)
    

