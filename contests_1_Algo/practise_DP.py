

def count_trajectory(n):

    '''
    Решите задачу о количестве способов достичь
    точки n из точки 1, если кузнечик умеет прыгать +1, +2 и *3.
    где *3 предполагается на клетку n кузнечик может допрыгнуть
    за раз если та клетка равна n/3
    '''
    '''
    можно так же запретить клетки создав список allowed из булевых значений
    где True то можно наступать на нее а False нельзя.
    if allowed:
        считаем всё тоже самое
    а иначе k[i] просто останется нулем (ноль способов попасть в эту клетку)
    '''
    if n==0:
        return 0
    k=[0]*(n+2)
    k[0]=0
    k[1]=1
    for i in range(2,n+1):
        if i%3==0: 
            k[i]=k[(i//3)]+k[i-1]+k[i-2] #если i делится на 3 без остатка то до
                                        # неe k[i-2] +k[i-3] +k[i//3]
        
        else:
            k[i]=k[i-1]+k[i-2] # в ином случае с той клетки он разом не прыгнет
                                #и придется прыгать по +1 и +2
    return k[n]
      
prs=[0,1]*6


nn=10

def min_cost_traj(n,price:list):
    '''
    Напишите функцию calculate_min_cost(n, price)
    вычисления наименьшей стоимость достижения клетки n из клетки 1
    '''
    '''
    здесь сразу два алгоритма, один вибирает самый выгодный по стоимости маршрут
    и последним элментом массива будет сумма которая понадобится для достижения
    данной точки
    другой же сторит маршрут по которому на каждой итерации выбирается точка
    если она есть в списке дважды то происходило уточнение
    '''
    k=[float('-inf'),price[1],price[1]+price[2]]+[0]*(n-2)
    marshr=[]
    for i in range(3,n+1):

        k[i]=min(k[i-1],k[i-2])+price[i]

    for z in range(len(k),1,-1):
        if k[z-1]< k[z-2]:
            marshr.append(z-1)
        else:
            marshr.append(z-2)
        
        
    return marshr




def ferz_play(N,M):
    '''
                                Игра ферзя
                                
    Рассмотрим игру «Ферзя в угол» для двух игроков. В левом верхнем
    углу доски размером N*M находится ферзь, который может двигаться
    только вправо-вниз. Игроки по очереди двигают ферзя, то есть за
    один ход игрок может переместить ферзя либо по вертикали вниз, либо
    по горизонтали вправо, либо во диагонали вправо-вниз. Выигрывает
    игрок, который поставит ферзя в правый нижний угол.
    Необходимо определить, какой из игроков может выиграть в этой игре
    независимо от ходов другого игрока (имеет выигрышную стратегию).
    ----1-----------tag
    for i in range(N):
        deck[-1][i]='+'
    
    for i in range(M):
        deck[i][-1]='+'
    for i in range(-1,-N-1,-1):
        for z in range(-1,-M-1,-1):
            if i==z:
                deck[z][i]='+'

    '''
    '''
    if N>M:
        deck[0][M-1]='+'
    elif M>N:
        deck[N-1][0]='+'
    else:
        deck[0][0]='+'
    -------1--------tag

    Будем заполнять доску знаками «+» и «-». Знак «+» будет означать, что данная
    клетка является выигрышной для ходящего с неё игрока
    (то есть если ферзь стоит в этой клетке, то игрок, который делает ход, может
    всегда выиграть), а знак «-» означает, что он проигрывает.
    Клетки последней строки, последнего столбца и диагонали, ведущей из правого
    нижнего угла необходимо отметить, как «+», так как если ферзь стоит в этой
    клетке, то ходящий игрок может выиграть одним ходом.
    '''
    deck= [[' ' for i in range(N)] for z in range(M)]
    '''
    Tag ---1---
    '''

  
   
    deck[-1][-1]='-' #выйгрышная точка m-строка n- элемент
    
  
    for i in range(N-1,-1,-1):
        for z in range(M-1,-1,-1):
            if deck[z][i]=='-':
                for q in range(z-1,-1,-1):
                    deck[q][i]='+'
                    
                for y in range(i-1,-1,-1):
                    deck[z][y]='+'
                    
                for x in range(-1,-N,-1): 
                    deck[z+x][i+x]='+'
                    
            elif deck[z][i]==' ':#иначе если клетка пустая то смотри на предыдущие состояния
                for q in range(i+1,N):
                    if deck[z][q]=='-':
                        deck[z][i]='+'
                        break
                    
                for q in range(z+1,M):
                    if deck[q][i]=='-':
                        deck[z][i]='+'
                        break
                dz=z
                di=i
                while dz+1<M+1 and di+1<N+1:
                    if deck[dz][di]=='-':
                        deck[z][i]='+'
                        break
                        
                    dz+=1
                    di+=1
                    
                if deck[z][i]==' ':
                    deck[z][i]='-'
    
    return deck
'''
dck=ferz_play(3,3)# N-столбцы, M-строк
for i in dck:
    print(i)
'''

def playking(N,M):
    '''
    То же самое что и с ферзем только для короля
    
    '''

    deck= [[' ' for i in range(N)] for z in range(M)]

    deck[-1][-1]='-'  #выйгрышная точка m-строка n- элемент

    for i in range(N-1,-1,-1):
        for z in range(M-1,-1,-1):
            if deck[z][i]=='-':
                deck[z][i-1]='+'
                deck[z-1][i-1]='+'
                deck[z-1][i]='+'
            elif deck[z][i]==' ':
                if i+1<N:# если находимся в границах длинны строки
                    if z+1<M:#если находимся в границах длинны столбцов
                        if deck[z+1][i]=='+' and deck[z][i+1]=='+' and deck[z+1][i+1]=='+':
                            deck[z][i]='-'# и если окружение вокруг состоит из "+", то там точно "-"
                        else:
                            deck[z][i]='+'# а если там хоть один "-" то ставим "+"
                    else: # если выходим за границы длинны столбцов
                        if deck[z][i+1]=='+': #смотрим что справа, если это "+", то ставим "-"
                            deck[z][i]='-'#

                        else:
                            deck[z][i]='+'#иначе "+"

                else:# если выходим за границы длинны строк
                    if deck[z+1][i]=='+':
                        deck[z][i]='-'
                    else:
                        deck[z][i]='+'
                    
                                           
    return deck

dck=playking(5,5)
for i in dck:
    print(i)

                        

    
    

